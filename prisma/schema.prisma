generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["queryCompiler", "driverAdapters"]
  output          = "../src/lib/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("CHAT_DATABASE_URL")
}

model User {
  uuid     String   @id
  lastSeen DateTime @default(now())
  name     String

  messages        Message[]
  chatMemberships ChatMembership[]
  messagesEvents  MessageEvent[]
}

enum ChatType {
  /// a direct chat between two users
  ONE_TO_ONE

  /// a group chat with two or more users
  GROUP

  /// a chat created after triggering an emergency
  EMERGENCY
}

model Chat {
  uuid String @id @default(uuid())
  name String

  lastUpdate DateTime @default(now())
  createdAt  DateTime @default(now())

  /// the time when the chat was archived, null if the chat is not archived
  archivedAt DateTime?

  type            ChatType         @default(GROUP)
  messages        Message[]
  chatMemberships ChatMembership[]

  @@index([lastUpdate])
}

enum ChatMembershipPermission {
  /// the user who has created the chat
  OWNER
  /// an admin can manage the chat, e.g. add or remove members
  ADMIN
  /// can read messages and send messages
  MEMBER
  /// can read messages, but cannot send messages
  GUEST
}

model ChatMembership {
  userId String
  user   User   @relation(fields: [userId], references: [uuid])

  chatId String
  chat   Chat   @relation(fields: [chatId], references: [uuid], onDelete: Cascade)

  /// indicates whether the user has deleted the chat
  hasDeleted Boolean @default(false)

  chatPermission ChatMembershipPermission @default(MEMBER)

  @@id([userId, chatId])
  @@index([userId])
  @@index([chatId])
}

enum MessageType {
  /// a system message, e.g. used for chat creation, chat archiving, adding or removing members
  SYSTEM_MSG

  /// a text message, e.g. "Hello, world!"
  TEXT_MSG

  /// a location message, e.g. { latitude: 52.5200, longitude: 13.4050 }
  LOCATION_MSG

  /// an image message, e.g. { url: "https://example.com/image.jpg" }
  IMAGE_MSG
}

model Message {
  uuid String      @id @default(uuid())
  type MessageType @default(TEXT_MSG)

  createdAt DateTime @default(now())

  chatId String
  chat   Chat   @relation(fields: [chatId], references: [uuid], onDelete: Cascade)

  senderId String?
  sender   User?   @relation(fields: [senderId], references: [uuid])

  // No contentId here anymore
  /// the events associated with this message
  messageEvents MessageEvent[]

  // Relation to the MessageContent model is now on the MessageContent side
  contentVersions MessageContent[]

  @@index([chatId, createdAt(sort: Asc)])
}

// we split the content of the message into a separate model to allow for versioning
model MessageContent {
  uuid String @id @default(uuid())

  /// versioning for content updates (e.g. editing messages)
  revision Int @default(0)

  /// the content of the message
  /// examples:
  /// - text: "Hello, world!"
  /// - location: { latitude: 52.5200, longitude: 13.4050 }
  /// - image: { url: "https://example.com/image.jpg" }
  payload Json

  // New messageId field and relation to Message
  message   Message? @relation(fields: [messageId], references: [uuid], onDelete: Cascade)
  messageId String?

  messageEvents MessageEvent[]

  @@index([messageId, revision(sort: Desc)])
}

enum MessageEventType {
  /// indicates that the message was created on the sender's side
  /// used for optimistic client updates
  CREATED

  /// indicates that the message was received by the server
  /// this is the first event that is stored in the database for a message
  STORED

  /// indicates that the message was sent to the recipient
  DISTRIBUTED

  /// indicates that the message was received by the recipient
  RECEIVED

  /// indicates that the message was read by the recipient
  READ
}

model MessageEvent {
  /// unique identifier for the message event, UUIDv7 is used for unique ordering of events
  uuid String           @id @default(uuid(7))
  type MessageEventType

  messageId String
  message   Message @relation(fields: [messageId], references: [uuid], onDelete: Cascade)

  // the user who triggered the event, not all types of events have a user associated with them
  // e.g. STORED and DISTRIBUTED events do not have a user associated with them
  userId String?
  user   User?   @relation(fields: [userId], references: [uuid])

  messageContentId String?
  messageContent   MessageContent? @relation(fields: [messageContentId], references: [uuid])

  // every message can only have one event per user, content version and event type
  @@unique([messageId, userId, type, messageContentId], name: "unique_message_event")
  @@index([messageId])
  @@index([userId])
}
