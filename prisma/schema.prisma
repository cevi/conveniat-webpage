generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["queryCompiler", "driverAdapters"]
  output          = "../src/lib/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("CHAT_DATABASE_URL")
}

model User {
  //
  // The unique identifier for the user as generated as id by payload.
  //
  uuid     String   @id
  lastSeen DateTime @default(now())

  //
  // The nickname of the user. Defaults to the user's nickname resp. name defined in payload.
  //
  name            String
  messages        Message[]
  chatMemberships ChatMembership[]
  messagesEvents  MessageEvent[]
}

model Chat {
  uuid       String   @id @default(uuid())
  name       String
  lastUpdate DateTime @default(now())

  messages        Message[]
  chatMemberships ChatMembership[]

  /// archived chats are read-only and cannot be modified
  isArchived Boolean @default(false)
}

enum ChatMembershipPermission {
  /// the user who has created the chat
  OWNER
  /// an admin can manage the chat, e.g. add or remove members
  ADMIN
  /// can read messages and send messages
  MEMBER
  /// can read messages, but cannot send messages
  GUEST
}

model ChatMembership {
  userId String
  user   User   @relation(fields: [userId], references: [uuid])

  chatId String
  chat   Chat   @relation(fields: [chatId], references: [uuid])

  /// indicates whether the user has deleted the chat
  hasDeleted Boolean @default(false)

  chatPermission ChatMembershipPermission @default(MEMBER)

  @@id([userId, chatId])
}

enum MessageType {
  SYSTEM // indicates that the message was generated by the system (e.g. "New Chat", "User joined")
  TEXT // indicates that the message is a text message
}

model Message {
  uuid      String      @id @default(uuid())
  content   String
  timestamp DateTime    @default(now())
  type      MessageType @default(TEXT)

  messageEvents MessageEvent[]

  chatId String
  chat   Chat   @relation(fields: [chatId], references: [uuid])

  // optional if send by the system, required if sent by a user
  senderId String?
  sender   User?   @relation(fields: [senderId], references: [uuid])
}

enum MessageEventType {
  CREATED // indicates that the message was created on the sender's side
  SERVER_RECEIVED // indicates that the message was received by the server
  SERVER_SENT // indicates that the message was sent to the recipient
  USER_RECEIVED // indicates that the message was received by the recipient
  USER_READ // indicates that the message was read by the recipient
}

model MessageEvent {
  uuid      String   @id @default(uuid())
  timestamp DateTime @default(now())

  messageId String
  message   Message @relation(fields: [messageId], references: [uuid])

  eventType MessageEventType

  userId String?
  user   User?   @relation(fields: [userId], references: [uuid])

  // add unique constraint
  @@unique([messageId, userId, eventType], name: "unique_message_event")
}
